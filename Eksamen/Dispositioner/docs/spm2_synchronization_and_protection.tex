\section{Synchronization and protection}

\subsection{Sub topics}

\begin{itemize}
	\item Data integrity - Concurrency challenge.
	\item Mutex and Semaphore.
	\item Mutex and Conditionals.
	\item Producer / Consumer problem.
	\item Dining philosophers.
	\item Dead locks.
\end{itemize}

\subsection{Curriculum}

\begin{itemize}
	\item Slides: "Thread Synchronization I and II".
	\item Kerrisk: Chapter 30: Thread Synchronization.
	\item Kerrisk: Chapter 31: Thread Safety and Per-Thread Storage (Speed read)".
	\item Kerrisk: Chapter 32: Thread Safety and Per-Thread Storage (Speed read)".
	\item Kerrisk: Chapter 53: Posix Semaphores (Named not in focus for this exercise)".
	\item OLA: "pthread-Tutorial" - chapters 4-6.
	\item OLA: "Producer/Consumer problem".
	\item OLA: "Dining Philosophers problem".
\end{itemize}

\subsection{Exercises}

\begin{itemize}
	\item Posix Threads
	\item Thread Synchronization I \& II
\end{itemize}

\newpage

\subsection{Data integrity - Concurrency challenge}

Selvom informations deling tråde imellem er en af de væsentligste fordele ved multitrådede applikationer, er det vigtigt at se sig for når flere tråde behandler den samme data.
Man bruger termet \textit{critical section} til at referere til et stykke kode der benytter en delt ressource, hvor dette bør gøres \textit{atomic}. Vi har derfor brug for en måde at sikre os eksklusiv adgang når der arbejdes på delte data.

\subsection{Mutex and Semaphore}

En ovenfornævnt kritisk sektion kan defineres ved hjælp af mutexes og semaphorer.

\subsubsection{Mutexes}

En tråd kan tage ejerskab over en mutex, dvs at mutexen låses, og ikke kan tages af andre tråde før den frigives af ejertråden og derved låses op. \\

En mutex skal initialiseres og destrueres.

\subsubsection{Semaphores}

\subsection{Mutex and Conditionals}

\subsection{Producer / Consumer problem}

\subsection{Dining philosophers}
Wikipedia om problemet findes \href{https://en.wikipedia.org/wiki/Dining_philosophers_problem}{her}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{figs/spm2/dining}
	\caption{Dining philophers problem illustrated. Med uret fra toppen: Platon, Konfuzius, Socrates, Voltaire og Descartes.}
	\label{fig:dining}
\end{figure}

\subsubsection{Løsninger}
I section~\ref{sec:deadlock} er fire betingelser for deadlocks beskrevet. Vores opgave er at bryde mindst én af disse.

\begin{enumerate}
	\item \textbf{Mutual exclution} - Nope, de skal have hver deres egen gaffel.
	\item \textbf{Hold and Wait} eller \textbf{Resource holding} - Heller ikke, de skal have to gafler for at spise.
	\item \textbf{No preemption\footnote{Læs om preemption i section~\ref{sec:execpu}}} - Nix, de må ikke tage hinandens gafler.
	\item \textbf{Circular wait} - Bingo! Vi kan bryde denne cykel!
\end{enumerate}

Dette kan imidlertid gøres på flere måder:

\paragraph{Ressource hierarchy solution}
Dette var Dijkstra's originale løsning på probelmet.

Ved at etablere en bestemt rækkefølge som ressourcerne skal ''tages'' i, kan vi bryde cyklen. For vores tilfælde vil gaflerne blive nummereret. Når en filosof så vil spise skal han først tage gaflen med de \textbf{mindste} nummer.

\paragraph{Arbitrator solution}
Hvis de kun kan samle \textit{begge} eller \textit{ingen} af gaflerne kan samles op kan problemet løses. Dette gøres ved at filosofferne skal spørge en tjener\footnote{Tjeneren kan implementeres som en mutex.} om tilladelse før de tage gaflerne, hvorefter de samler gafler op, indtil de har begge. 

Problemet bliver imidlertid så at kun én filosof kan spise af gangen, selv hvis der er flere gafler ledige.



\subsection{Dead locks}\label{sec:deadlock}
Deadlock er en situation hvor tråde ikke frigiver deres ressourcer fordi de venter på ressourcer som andre tråde ligeledes holder mens de venter på samme ting.\\

På wikipedia om \href{https://en.wikipedia.org/wiki/Deadlock}{deadlock} kan man læse om de fire betingelser som skal være overholdt for at en deadlock kan opstå:
\begin{enumerate}
	\item \textbf{Mutual exclution}\\
	Mindst én ressource skal være ''holdt'' i et \textit{non-shareable mode}\footnote{Kun én tråd kan bruge ressourcen af gangen.}.
	\item \textbf{Hold and Wait} eller \textbf{Resource holding}\\
	En tråd ''holder'' mindst én ressource og anmoder om flere ressourcer, hvor disse ''holdes'' af andre tråde.
	\item \textbf{No preemption\footnote{Læs om preemption i section~\ref{sec:execpu}}}\\
	En ressource kan kun frigives af tråden som holder den.
	\item \textbf{Circular wait}\\
	En tråd/process venter på en ressource som på tidspunktet holdes af en anden tråd/process. Denne anden tråd venter ligeledes på at den første tråd frigiver sin ressource.
\end{enumerate}

For at deadlocks ikke skal opstå, skal mindst én af de ovenstående betingelser brydes.
