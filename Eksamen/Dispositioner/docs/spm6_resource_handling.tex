\section{Resource handling}

\subsection{Sub topics}

\begin{itemize}
	\item RAII - What and why?
	\item Copy construction and the assignment operator.
	\item What is the concept begind a Counted SmartPointer?
	\item What is $boost::shared\_ptr<>$ and how do you use it?
\end{itemize}

\subsection{Curriculum}

\begin{itemize}
	\item Slides: "Resource Handling".
	\item OLA: "RAII - Resource Acquisition Is Initialiation".
	\item OLA: "SmartPointer".
	\item OLA: "Counted Body".
	\item OLA: "$boost::shared\_ptr$".
	\item OLA: "Rule of 3".
\end{itemize}

\subsection{Exercises}

\begin{itemize}
	\item Resource Handling.
\end{itemize}

\subsection{RAII - What and why?}

\subsection{Copy construction and the assignment operator}

\subsection{What is the concept begind a Counted SmartPointer?}

\subsection{What is $boost::shared\_ptr<>$ and how do you use it?}

$Shared\_ptr<>$ er en class template, der indeholder en pointer til et dynamisk allokeret objekt. Der stilles garanti for at objektet der peges på slettes når den sidste \textit{shared\_ptr} der peger på det enten resettes eller destrueres. En $shared\_ptr<>$ er en counted smart pointer, hvilket vil sige at der inkrementeres en counter for hver gang.

Eksempel:

Hvis en shared pointer, p1 peger på variabel a, er dens counter = 1, hvis en anden shared pointer p2, sættes lig p1 så er counter = 2. Hvis en tredje pointer også peger på a er counter lig 3 sov.

Kaldes populært en \textit{reference counted pointer}.

\subsubsection{How to use it}
\begin{itemize}
	\item Oprettelse af shared pointer: $boost::shared\_ptr<T> myPointer(new T(InitValue))$.
	\item Assignment: $myPointer1 = myPointer2$.
	\item Get references: $myPointer.use\_count()$ returnerer antal referencer.
	\item Reset: $myPointer.reset()$ dekrementerer counter.
\end{itemize}

\textit{Dangling pointers} kan opstå hvis to shared pointers har cirkulære referencer, og ingen har referencer til dem. Der kan bruges $weak\_ptr$ til at undgå dette.

\paragraph{boost::weak\_ptr}
kan tildeles en shared\_ptr, som den deler counter med.
Det som weak pointeren peger på skal ikke være kritisk at have til rådighed, idet garbage collectoren sletter objektet der peges på, hvis der kun er en weak pointer der peger på det (det er her det kan bruges til at undgå cirkulære referencer)

\textit{lock()} funktionen laver en shared pointer \todo{laver en ny eller laver om på weak pointeren??}, der peger på det som weak pointeren peger på. Dette medfører at dennes hukommelse ikke deallokeres før vi går ud af scope.