\section{Resource handling}

\subsection{Sub topics}

\begin{itemize}
	\item RAII - What and why?
	\item Copy construction and the assignment operator.
	\item What is the concept begind a Counted SmartPointer?
	\item What is $boost::shared\_ptr<>$ and how do you use it?
\end{itemize}

\subsection{Curriculum}

\begin{itemize}
	\item Slides: "Resource Handling".
	\item OLA: "RAII - Resource Acquisition Is Initialiation".
	\item OLA: "SmartPointer".
	\item OLA: "Counted Body".
	\item OLA: "$boost::shared\_ptr$".
	\item OLA: "Rule of 3".
\end{itemize}

\subsection{Exercises}

\begin{itemize}
	\item Resource Handling.
\end{itemize}

\subsection{RAII - What and why?}\label{sec:raii}
\textit{''Wrap up all recources in their own object that handles their lifetime and put object on stack''}\\

Et idiom brugt til sikker brug af ressourcer, for at undgå memory-leaks. Ideen er at ressourcen allokeres under objektets oprettelse og deallokeres ved destruktion.

\subsubsection{Why we need RAII}
Hvis vi har koden vist i udsnit~\ref{code:raiiproblem}. Heri kan vi risikere at funktionen \textit{returner} før d og c bliver deallokeret og så dør baby.

\begin{lstlisting}[caption=Problem som skal løses af RAII, label=code:raiiproblem]
void f() {
	Client* c = new Client;
	Data* d   = acuireData(c);
	
	if(...)
		return;
		
	delete d;
	delete d; 
}
\end{lstlisting}

Men hvis vi wrapper d og c i deres eget objekt, vil de automatisk blive deallokeret når vi har ud af scope - om det så bliver på \textit{return} eller når vi rammer linje 10.

\subsection{Copy construction and the assignment operator}


\subsection{What is the concept begind a Counted SmartPointer?}

\subsection{What is $boost::shared\_ptr<>$ and how do you use it?}
